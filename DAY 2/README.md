# VSD Tapeout Program - Day 2 Progress

Welcome to my documentation of Day 2 progress in the **VSD Tapeout Program**. This README tracks my learning journey through digital design concepts and their practical implementation.

---

## ðŸ“š Table of Contents

1. [Timing Libraries (.lib) Introduction](#1-timing-libraries-lib-introduction)
2. [Hierarchical vs Flat Synthesis](#2-hierarchical-vs-flat-synthesis)
3. [Various Flop Coding Styles and Optimization](#3-various-flop-coding-styles-and-optimization)

---

## 1. Timing Libraries (.lib) Introduction
### Opening Technology File
```
gvim ../lib/sky130_fd_Sc_hd_tt_025C_1v80.lib
```
![alt text](<Opening Command .lib.jpg>)

![alt text](<.lib screenshot.jpg>)
### Overview
Currently learning about the library files (.lib) in the SkyWater 130nm technology node. These files are fundamental to the digital design flow and contain critical information for synthesis and timing analysis.

### Key Concepts Learned

#### Process Corners and PVT Variations
- **PVT**: Process, Voltage, and Temperature variations
- **TT**: Typical-Typical corner (nominal conditions)
- **Process Corners**: Different combinations that account for manufacturing variations
- **Design Requirement**: Circuits must function correctly across all targeted corners

#### Standard Cell Library Structure
- **.lib files**: Act as a "bucket" of standard cells
- **Cell Definition**: Keyword `cell` indicates the beginning of a new standard cell definition
- **Gate Variants**: Multiple implementations of the same logic function

#### Standard Cell Characteristics
**AND Gate Example:**
- Multiple input configurations: 2, 3, 4, 5-input variants
- **Drive Strength Variations**: Cells with different widths for varying drive capabilities
- **Cell Information**: Each cell contains detailed specifications for:
  - **Timing**: Propagation delays and setup/hold times
  - **Power**: Static and dynamic power consumption
  - **Area**: Physical footprint of the cell

### Technology Node Details
- **Process**: SkyWater 130nm technology
- **Library Naming Convention**: Incorporates process corner information in filename

---

## 2. Hierarchical vs Flat Synthesis
### Overview
Synthesis can be performed in two distinct approaches: **hierarchical** and **flat** synthesis. Understanding the difference between these methodologies is crucial for optimizing design flow, debugging, and managing complex digital systems.

---

### Example Design: Multiple Modules Architecture

The following Verilog code demonstrates a hierarchical design with two sub-modules:

```verilog
module sub_module2 (input a, input b, output y);
    assign y = a | b;  // OR gate implementation
endmodule

module sub_module1 (input a, input b, output y);
    assign y = a & b;  // AND gate implementation
endmodule

module multiple_modules (input a, input b, input c, output y);
    wire net1;
    sub_module1 u1(.a(a), .b(b), .y(net1));  // net1 = a & b
    sub_module2 u2(.a(net1), .b(c), .y(y));  // y = net1 | c = (a & b) | c
endmodule
```

**Logic Function**: `y = (a & b) | c`

---


### Hierarchical Synthesis

#### Characteristics
- **Module Preservation**: Sub-modules maintain their individual identity in the netlist
- **Structured Organization**: Design hierarchy is preserved from RTL to gate-level
- **Instance-Based**: Each module instance appears as a separate entity
#### Generated Netlist Graphical View (Hierarchical) 

![alt text](<Hierarchial synthesis.jpg>)

#### Generated Netlist (Hierarchical)
```verilog
/* Generated by Yosys 0.33 - Hierarchical Synthesis */

module multiple_modules(a, b, c, y);
  input a, b, c;
  output y;
  wire net1;
  
  sub_module1 u1 (
    .a(a),
    .b(b),
    .y(net1)
  );
  
  sub_module2 u2 (
    .a(net1),
    .b(c),
    .y(y)
  );
endmodule

module sub_module1(a, b, y);
  input a, b;
  output y;
  wire _0, _1, _2;
  
  sky130_fd_sc_hd__and2_0 _3 (
    .A(_1),
    .B(_0),
    .X(_2)
  );
  
  assign _1 = b;
  assign _0 = a;
  assign y = _2;
endmodule

module sub_module2(a, b, y);
  input a, b;
  output y;
  wire _0, _1, _2;
  
  sky130_fd_sc_hd__or2_0 _3 (
    .A(_1),
    .B(_0),
    .X(_2)
  );
  
  assign _1 = b;
  assign _0 = a;
  assign y = _2;
endmodule
```

#### Advantages of Hierarchical Synthesis
- **Modular Debugging**: Easy to trace and debug individual modules
- **Reusability**: Sub-modules can be reused across different designs
- **Design Clarity**: Maintains logical organization of the original design
- **Incremental Changes**: Modifications to one module don't affect others
- **Team Collaboration**: Different engineers can work on separate modules

---

### Flat Synthesis

#### Methodology
Flat synthesis is achieved using the `flatten` command in Yosys, which dissolves the design hierarchy.

```bash
flatten
```

#### Characteristics
- **Single Module**: All logic is merged into one top-level module
- **No Sub-modules**: Hierarchy is completely removed
- **Direct Gate Implementation**: Logic gates are directly instantiated

#### Generated Netlist Graphical View (Flat)
 ![alt text](<Flat synthesis.jpg>)

#### Generated Netlist (Flat)
```verilog
/* Generated by Yosys 0.33 - Flat Synthesis */

module multiple_modules(a, b, c, y);
  input a, b, c;
  output y;
  wire _0, _1, _2, _3, _4, _5;
  wire net1;
  wire \u1.a, \u1.b, \u1.y;
  wire \u2.a, \u2.b, \u2.y;
  
  // AND gate from sub_module1
  sky130_fd_sc_hd__and2_0 _6 (
    .A(_1),
    .B(_0),
    .X(_2)
  );
  
  // OR gate from sub_module2
  sky130_fd_sc_hd__or2_0 _7 (
    .A(_4),
    .B(_3),
    .X(_5)
  );
  
  // Signal assignments
  assign _4 = \u2.b;
  assign _3 = \u2.a;
  assign \u2.y = _5;
  assign \u2.a = net1;
  assign \u2.b = c;
  assign y = \u2.y;
  assign _1 = \u1.b;
  assign _0 = \u1.a;
  assign \u1.y = _2;
  assign \u1.a = a;
  assign \u1.b = b;
  assign net1 = \u1.y;
endmodule
```

#### Advantages of Flat Synthesis
- **Global Optimization**: Synthesizer can optimize across the entire design
- **Better Timing**: Potential for improved timing optimization
- **Reduced Overhead**: Eliminates module interface overhead
- **Simplified Netlist**: Single module structure for some tools

---

### Sub-Module Level Synthesis

#### Command Usage
```bash
synth -top <module_name>
```

This command controls which module serves as the synthesis target.
#### Generated Graphical View
![alt text](<graphical view of synthesised submodule.jpg>)

#### Use Cases and Benefits

**1. Multiple Instance Optimization**
- When multiple instances of the same sub-module exist
- Synthesizer optimizes the sub-module once and reuses the optimized version
- Significant time savings for designs with repeated blocks

**2. Divide and Conquer Strategy**
- **Problem**: Large designs may overwhelm the synthesizer
- **Solution**: Break down complex designs into manageable sub-modules
- **Process**: Synthesize each sub-module individually, then stitch together

**3. Incremental Design Flow**
- Modify and re-synthesize only changed modules
- Faster iteration cycles during design development
- Maintains optimization quality for unchanged modules

#### Example: Sub-Module Synthesis
```bash
# Synthesize only sub_module1
synth -top sub_module1

# Synthesize only sub_module2  
synth -top sub_module2

# Finally synthesize the top module
synth -top multiple_modules
```

---

### Comparison Table

| Aspect | Hierarchical Synthesis | Flat Synthesis |
|--------|----------------------|----------------|
| **Module Structure** | Preserved | Dissolved |
| **Debugging** | Easy, module-level | Complex, gate-level |
| **Optimization** | Local per module | Global across design |
| **Reusability** | High | Low |
| **Synthesis Time** | Faster for large designs | Slower for large designs |
| **Timing Analysis** | Module boundaries may limit optimization | Better timing optimization potential |
| **Memory Usage** | Lower | Higher |
| **Design Changes** | Localized impact | Global impact |

---

### Best Practices

#### When to Use Hierarchical Synthesis
- **Large designs** with clear module boundaries
- **Reusable IP blocks** that appear multiple times
- **Team-based development** with module ownership
- **Designs requiring incremental changes**

#### When to Use Flat Synthesis
- **Small to medium designs** where global optimization is beneficial
- **Timing-critical paths** that cross module boundaries
- **Designs requiring maximum performance optimization**
- **Simple designs** without complex hierarchy

#### Hybrid Approach
- Use hierarchical synthesis for development and debugging
- Apply selective flattening for timing-critical paths
- Maintain hierarchy for reusable blocks while flattening custom logic

---

### Key Takeaways

1. **Hierarchical synthesis** preserves design structure and enables modular development
2. **Flat synthesis** allows global optimization but sacrifices design clarity
3. **Sub-module synthesis** provides granular control over the synthesis process
4. **Choice depends** on design complexity, team structure, and optimization goals
5. **Modern flows** often use hybrid approaches combining both methodologies

---

## 3. Various Flop Coding Styles and Optimization

### Overview
Sequential logic elements, particularly flip-flops (flops), are fundamental building blocks in digital design that address critical timing and stability issues in combinational logic circuits.

---

### Why Flip-Flops Are Essential

#### The Glitch Problem
**Glitches** are momentary, unwanted spikes in combinational logic outputs that occur due to:
- **Non-zero Propagation Delay**: Gates don't switch instantaneously
- **Unequal Path Delays**: Different signal paths have varying delays
- **Race Conditions**: Multiple inputs changing simultaneously

#### Glitch Propagation in Large Designs
```
Input â†’ [Comb Logic Stage 1] â†’ [Comb Logic Stage 2] â†’ [Comb Logic Stage 3] â†’ Output
         â†“ Glitch              â†“ Amplified Glitch    â†“ Unstable Output
```

**Problem**: In large combinational circuits, glitches propagate and amplify through multiple stages, causing:
- **Signal Instability**: Outputs never settle to stable values
- **Timing Violations**: Unpredictable signal transitions
- **System Malfunction**: Incorrect logic operations

#### Solution: Periodic Data Capture
**Flip-flops** solve this by:
- **Clocked Operation**: Capturing data only at specific clock edges
- **Signal Stabilization**: Allowing combinational logic to settle between clock cycles
- **Glitch Isolation**: Breaking the propagation chain of unwanted transitions

---

### Flip-Flop Synthesis Commands

Sequential logic synthesis requires specific commands different from combinational logic:

```bash
# Standard flip-flop synthesis flow
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
read_verilog dff_asyncres.v
synth -top dff_asyncres
dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
show
```

#### Command Breakdown
| Command | Purpose |
|---------|---------|
| `read_liberty` | Load standard cell library with timing information |
| `read_verilog` | Read RTL design file |
| `synth -top` | Perform RTL synthesis |
| **`dfflibmap`** | **Map D flip-flops to library cells** |
| `abc` | Technology mapping and optimization |
| `show` | Generate schematic visualization |

**Key Difference**: The `dfflibmap` command specifically handles flip-flop mapping to standard cells.

---

### Flip-Flop Design Varieties

Digital designs utilize various flip-flop configurations based on control and timing requirements:

#### Control Signal Types
- **Synchronous Reset**: Reset occurs only at clock edge
- **Asynchronous Reset**: Reset occurs immediately when asserted
- **Asynchronous Set**: Set occurs immediately when asserted
- **Enable Control**: Data update controlled by enable signal

#### Flip-Flop Types by Functionality
- **D Flip-Flop**: Data type, most commonly used
- **T Flip-Flop**: Toggle type, useful for counters
- **JK Flip-Flop**: Jack-Kilby type, universal flip-flop
- **SR Flip-Flop**: Set-Reset type, basic latch functionality

---

### D Flip-Flop Implementations

#### 1. D Flip-Flop with Asynchronous Reset

**Characteristics:**
- Reset signal overrides clock and data
- Output immediately goes to '0' when reset is asserted
- Most common implementation in digital designs

**Verilog Code:**
```verilog
module dff_asyncres(input clk, input async_reset, input d, output reg q);
    always @(posedge clk or posedge async_reset) begin
        if (async_reset)
            q <= 1'b0;
        else
            q <= d;
    end
endmodule
```

**Key Features:**
- Sensitive to both `posedge clk` and `posedge async_reset`
- Reset has higher priority than data
- Non-blocking assignment (`<=`) for proper sequential logic

**Simulation Waveform:**
![alt text](<WhatsApp Image 2025-09-26 at 07.32.08_ba49c383.jpg>)

**Synthesized Circuit:**
![alt text](<WhatsApp Image 2025-09-26 at 07.52.41_1154d031.jpg>)

---

#### 2. D Flip-Flop with Asynchronous Set

**Characteristics:**
- Set signal immediately forces output to '1'
- Similar to async reset but sets instead of clears
- Less commonly used than reset variants

**Verilog Code:**
```verilog
module dff_async_set(input clk, input async_set, input d, output reg q);
    always @(posedge clk or posedge async_set) begin
        if (async_set)
            q <= 1'b1;
        else
            q <= d;
    end
endmodule
```

**Key Features:**
- Set signal forces output high immediately
- Asynchronous operation independent of clock
- Useful for initialization and control logic

**Simulation Waveform:**
![alt text](<WhatsApp Image 2025-09-26 at 07.35.47_2db24016.jpg>)

**Synthesized Circuit:**
![alt text](<WhatsApp Image 2025-09-26 at 08.06.31_f3e84255.jpg>)

---

#### 3. D Flip-Flop with Synchronous Reset

**Characteristics:**
- Reset occurs only at clock edge
- More predictable timing behavior
- Better for timing closure in high-speed designs

**Verilog Code:**
```verilog
module dff_syncres(input clk, input sync_reset, input d, output reg q);
    always @(posedge clk) begin
        if (sync_reset)
            q <= 1'b0;
        else
            q <= d;
    end
endmodule
```

**Key Features:**
- Only sensitive to `posedge clk`
- Reset evaluated only at clock edges
- Better timing predictability
- Requires active clock for reset operation

**Simulation Waveform:**
![alt text](<WhatsApp Image 2025-09-26 at 07.45.45_e8ef6a6a.jpg>)

**Synthesized Circuit:**
![alt text](<WhatsApp Image 2025-09-26 at 08.47.44_bc3cff1d.jpg>)

---

### Special Optimizations: Multiplication by Constants

#### Multiplication by 2 - Bit Shifting Optimization

**Concept**: Multiplying by 2 is equivalent to left-shifting by 1 bit

**Example**: `y = a * 2`
```verilog
// Instead of actual multiplier hardware
assign y = a << 1;  // Left shift by 1 position
```

**Hardware Implementation**:
```
Input:  a[n-1:0]
Output: y[n:0] = {a[n-1:0], 1'b0}
```

**Optimization**: No multiplication hardware required - simple rewiring!

#### Multiplication by 9 - Bit Concatenation Optimization  

**Concept**: `9 Ã— a = 8 Ã— a + a = (a << 3) + a`

**Example**: `y = a * 9`
```verilog
// Mathematical equivalence: 9a = 8a + a
assign y = {a, a};  // Concatenate a with itself
// OR
assign y = (a << 3) + a;  // 8a + a
```

**Hardware Implementation**:
```
Input:  a[n-1:0]
Output: y[2n-1:0] = {a[n-1:0], a[n-1:0]}
```

**Synthesis Optimization**: Tool automatically recognizes these patterns and implements efficient rewiring instead of complex multiplier circuits.

---

### Synthesis Tool Intelligence

#### Automatic Pattern Recognition
Modern synthesis tools like **Yosys** automatically detect:
- **Multiplication by powers of 2**: Implemented as bit shifts
- **Multiplication by specific constants**: Optimized using bit manipulation
- **Common arithmetic patterns**: Replaced with efficient logic structures

#### Resource Optimization Benefits
- **No Multiplier DSPs**: Saves dedicated multiplier resources
- **Reduced Area**: Simple wiring vs. complex arithmetic units  
- **Lower Power**: No switching activity in unused multipliers
- **Faster Timing**: Direct wiring has minimal delay

#### Example Optimization Results
```verilog
// Original RTL
assign result = input_val * 2;

// Optimized Implementation (Tool generates)
assign result = {input_val, 1'b0};  // Just rewiring!
```

---

### Key Takeaways

1. **Flip-flops eliminate glitches** by providing periodic data capture points
2. **Different reset types** serve different design requirements and timing needs
3. **Synthesis commands differ** for sequential logic compared to combinational logic
4. **Tool optimizations** can significantly improve area and timing for arithmetic operations
5. **Proper coding style** is essential for predictable synthesis results
6. **Understanding hardware implications** helps write more efficient RTL code

The choice of flip-flop type and optimization strategy should align with overall design goals, timing requirements, and target technology constraints.

---


## ðŸ”— Project Information

**Program**: VSD Tapeout Program  
**Duration**: 10 weeks  
**Focus**: RISC-V chip tapeout collaboration  
**Technology**: SkyWater 130nm PDK

---

*This documentation will be updated daily as I progress through the tapeout program. Each section will be expanded with detailed explanations, examples, and key learnings.*