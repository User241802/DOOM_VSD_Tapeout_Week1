# VSD Tapeout Program - Day 2 Progress

Welcome to my documentation of Day 2 progress in the **VSD Tapeout Program**. This README tracks my learning journey through digital design concepts and their practical implementation.

---

## üìö Table of Contents

1. [Timing Libraries (.lib) Introduction](#1-timing-libraries-lib-introduction)
2. [Hierarchical vs Flat Synthesis](#2-hierarchical-vs-flat-synthesis)
3. [Various Flop Coding Styles and Optimization](#3-various-flop-coding-styles-and-optimization)

---

## 1. Timing Libraries (.lib) Introduction
### Opening Technology File
```
gvim ../lib/sky130_fd_Sc_hd_tt_025C_1v80.lib
```
![alt text](<WhatsApp Image 2025-09-26 at 05.27.13_91fac3b1.jpg>)

![alt text](<WhatsApp Image 2025-09-26 at 05.33.27_2af9b0c3.jpg>)
### Overview
Currently learning about the library files (.lib) in the SkyWater 130nm technology node. These files are fundamental to the digital design flow and contain critical information for synthesis and timing analysis.

### Key Concepts Learned

#### Process Corners and PVT Variations
- **PVT**: Process, Voltage, and Temperature variations
- **TT**: Typical-Typical corner (nominal conditions)
- **Process Corners**: Different combinations that account for manufacturing variations
- **Design Requirement**: Circuits must function correctly across all targeted corners

#### Standard Cell Library Structure
- **.lib files**: Act as a "bucket" of standard cells
- **Cell Definition**: Keyword `cell` indicates the beginning of a new standard cell definition
- **Gate Variants**: Multiple implementations of the same logic function

#### Standard Cell Characteristics
**AND Gate Example:**
- Multiple input configurations: 2, 3, 4, 5-input variants
- **Drive Strength Variations**: Cells with different widths for varying drive capabilities
- **Cell Information**: Each cell contains detailed specifications for:
  - **Timing**: Propagation delays and setup/hold times
  - **Power**: Static and dynamic power consumption
  - **Area**: Physical footprint of the cell

### Technology Node Details
- **Process**: SkyWater 130nm technology
- **Library Naming Convention**: Incorporates process corner information in filename

---

## 2. Hierarchical vs Flat Synthesis
### Overview
Synthesis can be performed in two distinct approaches: **hierarchical** and **flat** synthesis. Understanding the difference between these methodologies is crucial for optimizing design flow, debugging, and managing complex digital systems.

---

### Example Design: Multiple Modules Architecture

The following Verilog code demonstrates a hierarchical design with two sub-modules:

```verilog
module sub_module2 (input a, input b, output y);
    assign y = a | b;  // OR gate implementation
endmodule

module sub_module1 (input a, input b, output y);
    assign y = a & b;  // AND gate implementation
endmodule

module multiple_modules (input a, input b, input c, output y);
    wire net1;
    sub_module1 u1(.a(a), .b(b), .y(net1));  // net1 = a & b
    sub_module2 u2(.a(net1), .b(c), .y(y));  // y = net1 | c = (a & b) | c
endmodule
```

**Logic Function**: `y = (a & b) | c`

---


### Hierarchical Synthesis

#### Characteristics
- **Module Preservation**: Sub-modules maintain their individual identity in the netlist
- **Structured Organization**: Design hierarchy is preserved from RTL to gate-level
- **Instance-Based**: Each module instance appears as a separate entity
#### Generated Netlist Graphical View (Hierarchical) 

![alt text](<WhatsApp Image 2025-09-26 at 05.41.57_251163c7.jpg>)

#### Generated Netlist (Hierarchical)
```verilog
/* Generated by Yosys 0.33 - Hierarchical Synthesis */

module multiple_modules(a, b, c, y);
  input a, b, c;
  output y;
  wire net1;
  
  sub_module1 u1 (
    .a(a),
    .b(b),
    .y(net1)
  );
  
  sub_module2 u2 (
    .a(net1),
    .b(c),
    .y(y)
  );
endmodule

module sub_module1(a, b, y);
  input a, b;
  output y;
  wire _0, _1, _2;
  
  sky130_fd_sc_hd__and2_0 _3 (
    .A(_1),
    .B(_0),
    .X(_2)
  );
  
  assign _1 = b;
  assign _0 = a;
  assign y = _2;
endmodule

module sub_module2(a, b, y);
  input a, b;
  output y;
  wire _0, _1, _2;
  
  sky130_fd_sc_hd__or2_0 _3 (
    .A(_1),
    .B(_0),
    .X(_2)
  );
  
  assign _1 = b;
  assign _0 = a;
  assign y = _2;
endmodule
```

#### Advantages of Hierarchical Synthesis
- **Modular Debugging**: Easy to trace and debug individual modules
- **Reusability**: Sub-modules can be reused across different designs
- **Design Clarity**: Maintains logical organization of the original design
- **Incremental Changes**: Modifications to one module don't affect others
- **Team Collaboration**: Different engineers can work on separate modules

---

### Flat Synthesis

#### Methodology
Flat synthesis is achieved using the `flatten` command in Yosys, which dissolves the design hierarchy.

```bash
flatten
```

#### Characteristics
- **Single Module**: All logic is merged into one top-level module
- **No Sub-modules**: Hierarchy is completely removed
- **Direct Gate Implementation**: Logic gates are directly instantiated

#### Generated Netlist Graphical View (Flat)
 ![alt text](<WhatsApp Image 2025-09-26 at 06.04.37_6f76b358.jpg>)

#### Generated Netlist (Flat)
```verilog
/* Generated by Yosys 0.33 - Flat Synthesis */

module multiple_modules(a, b, c, y);
  input a, b, c;
  output y;
  wire _0, _1, _2, _3, _4, _5;
  wire net1;
  wire \u1.a, \u1.b, \u1.y;
  wire \u2.a, \u2.b, \u2.y;
  
  // AND gate from sub_module1
  sky130_fd_sc_hd__and2_0 _6 (
    .A(_1),
    .B(_0),
    .X(_2)
  );
  
  // OR gate from sub_module2
  sky130_fd_sc_hd__or2_0 _7 (
    .A(_4),
    .B(_3),
    .X(_5)
  );
  
  // Signal assignments
  assign _4 = \u2.b;
  assign _3 = \u2.a;
  assign \u2.y = _5;
  assign \u2.a = net1;
  assign \u2.b = c;
  assign y = \u2.y;
  assign _1 = \u1.b;
  assign _0 = \u1.a;
  assign \u1.y = _2;
  assign \u1.a = a;
  assign \u1.b = b;
  assign net1 = \u1.y;
endmodule
```

#### Advantages of Flat Synthesis
- **Global Optimization**: Synthesizer can optimize across the entire design
- **Better Timing**: Potential for improved timing optimization
- **Reduced Overhead**: Eliminates module interface overhead
- **Simplified Netlist**: Single module structure for some tools

---

### Sub-Module Level Synthesis

#### Command Usage
```bash
synth -top <module_name>
```

This command controls which module serves as the synthesis target.
#### Generated Graphical View
![alt text](<WhatsApp Image 2025-09-26 at 06.16.28_c96f7606.jpg>)

#### Use Cases and Benefits

**1. Multiple Instance Optimization**
- When multiple instances of the same sub-module exist
- Synthesizer optimizes the sub-module once and reuses the optimized version
- Significant time savings for designs with repeated blocks

**2. Divide and Conquer Strategy**
- **Problem**: Large designs may overwhelm the synthesizer
- **Solution**: Break down complex designs into manageable sub-modules
- **Process**: Synthesize each sub-module individually, then stitch together

**3. Incremental Design Flow**
- Modify and re-synthesize only changed modules
- Faster iteration cycles during design development
- Maintains optimization quality for unchanged modules

#### Example: Sub-Module Synthesis
```bash
# Synthesize only sub_module1
synth -top sub_module1

# Synthesize only sub_module2  
synth -top sub_module2

# Finally synthesize the top module
synth -top multiple_modules
```

---

### Comparison Table

| Aspect | Hierarchical Synthesis | Flat Synthesis |
|--------|----------------------|----------------|
| **Module Structure** | Preserved | Dissolved |
| **Debugging** | Easy, module-level | Complex, gate-level |
| **Optimization** | Local per module | Global across design |
| **Reusability** | High | Low |
| **Synthesis Time** | Faster for large designs | Slower for large designs |
| **Timing Analysis** | Module boundaries may limit optimization | Better timing optimization potential |
| **Memory Usage** | Lower | Higher |
| **Design Changes** | Localized impact | Global impact |

---

### Best Practices

#### When to Use Hierarchical Synthesis
- **Large designs** with clear module boundaries
- **Reusable IP blocks** that appear multiple times
- **Team-based development** with module ownership
- **Designs requiring incremental changes**

#### When to Use Flat Synthesis
- **Small to medium designs** where global optimization is beneficial
- **Timing-critical paths** that cross module boundaries
- **Designs requiring maximum performance optimization**
- **Simple designs** without complex hierarchy

#### Hybrid Approach
- Use hierarchical synthesis for development and debugging
- Apply selective flattening for timing-critical paths
- Maintain hierarchy for reusable blocks while flattening custom logic

---

### Key Takeaways

1. **Hierarchical synthesis** preserves design structure and enables modular development
2. **Flat synthesis** allows global optimization but sacrifices design clarity
3. **Sub-module synthesis** provides granular control over the synthesis process
4. **Choice depends** on design complexity, team structure, and optimization goals
5. **Modern flows** often use hybrid approaches combining both methodologies

---

## 3. Various Flop Coding Styles and Optimization

*[This section will be documented as I progress through the material]*

### Coming Soon:
- Different flip-flop coding techniques in Verilog/SystemVerilog
- Synthesis optimization strategies for sequential elements
- Clock domain considerations and best practices

---

## üìù Progress Tracking

- ‚úÖ **Day 2**: Timing Libraries Introduction - **Completed**
- ‚è≥ **Day 2**: Hierarchical vs Flat Synthesis - **In Progress**
- ‚è≥ **Day 2**: Flop Coding Styles - **Pending**

---

## üîó Project Information

**Program**: VSD Tapeout Program  
**Duration**: 10 weeks  
**Focus**: RISC-V chip tapeout collaboration  
**Technology**: SkyWater 130nm PDK

---

*This documentation will be updated daily as I progress through the tapeout program. Each section will be expanded with detailed explanations, examples, and key learnings.*